package access2

import (
	"encoding/binary"
	"errors"
	"fmt"
	"sort"

	"github.com/BranchAndLink/paosp/types"
	"github.com/BranchAndLink/paosp/utils"
)

type Packable interface {
	PackInto(p *PutAccess)
	PayloadSize() int
	IsContainer() bool
	ComputeSizes(nestedHeaderSize []int16) (int, error)
	PackIntoAfterComputeSize(p *PutAccess, buffer []byte, nestedHeaderSize []int16) error
}

type PackInt16 int16

func (v PackInt16) PackInto(p *PutAccess) {
	p.AddInt16(int16(v))
}

func (v PackInt16) PackIntoUnsorted(p *PutAccess) {
	p.AddInt16(int16(v))
}

type PackInt32 int32

func (v PackInt32) PackInto(p *PutAccess) {
	p.AddInt32(int32(v))
}

type PackInt64 int64

func (v PackInt64) PackInto(p *PutAccess) {
	p.AddInt64(int64(v))
}

func (v PackInt32) PackIntoUnsorted(p *PutAccess) {
	p.AddInt32(int32(v))
}

type PackFloat32 float32

func (v PackFloat32) PackInto(p *PutAccess) {
	p.AddFloat32(float32(v))
}

func (v PackFloat32) PackIntoUnsorted(p *PutAccess) {
	p.AddFloat32(float32(v))
}

type PackFloat64 float64

func (v PackFloat64) PackInto(p *PutAccess) {
	p.AddFloat64(float64(v))
}

func (v PackFloat64) PackIntoUnsorted(p *PutAccess) {
	p.AddFloat64(float64(v))
}

type PackBool bool

func (v PackBool) PackInto(p *PutAccess) {
	p.AddBool(bool(v))
}

func (v PackBool) PackIntoUnsorted(p *PutAccess) {
	p.AddBool(bool(v))
}

type PackNullableInt16 struct{ V *int16 }

func (v PackNullableInt16) PackInto(p *PutAccess) {
	p.AddNullableInt16(v.V)
}

func (v PackNullableInt16) PackIntoUnsorted(p *PutAccess) {
	p.AddNullableInt16(v.V)
}

func NullableInt16(val *int16) PackNullableInt16 {
	return PackNullableInt16{V: val}
}

type PackNullableInt32 struct{ V *int32 }

func (v PackNullableInt32) PackInto(p *PutAccess) {
	p.AddNullableInt32(v.V)
}

func (v PackNullableInt32) PackIntoUnsorted(p *PutAccess) {
	p.AddNullableInt32(v.V)
}

func NullableInt32(val *int32) PackNullableInt32 {
	return PackNullableInt32{V: val}
}

type PackNullableInt64 struct{ V *int64 }

func (v PackNullableInt64) PackInto(p *PutAccess) {
	p.AddNullableInt64(v.V)
}

func (v PackNullableInt64) PackIntoUnsorted(p *PutAccess) {
	p.AddNullableInt64(v.V)
}

func NullableInt64(val *int64) PackNullableInt64 {
	return PackNullableInt64{V: val}
}

type PackNullableFloat32 struct{ V *float32 }

func (v PackNullableFloat32) PackInto(p *PutAccess) {
	p.AddNullableFloat32(v.V)
}

func (v PackNullableFloat32) PackIntoUnsorted(p *PutAccess) {
	p.AddNullableFloat32(v.V)
}

func NullableFloat32(val *float32) PackNullableFloat32 {
	return PackNullableFloat32{V: val}
}

type PackNullableFloat64 struct{ V *float64 }

func (v PackNullableFloat64) PackInto(p *PutAccess) {
	p.AddNullableFloat64(v.V)
}

func (v PackNullableFloat64) PackIntoUnsorted(p *PutAccess) {
	p.AddNullableFloat64(v.V)
}

func NullableFloat64(val *float64) PackNullableFloat64 {
	return PackNullableFloat64{V: val}
}

type PackNullableBool struct{ V *bool }

func (v PackNullableBool) PackInto(p *PutAccess) {
	p.AddNullableBool(v.V)
}

func (v PackNullableBool) PackIntoUnsorted(p *PutAccess) {
	p.AddNullableBool(v.V)
}

func NullableBool(val *bool) PackNullableBool {
	return PackNullableBool{V: val}
}

type PackString string

func (v PackString) PackInto(p *PutAccess) {
	p.AddString(string(v))
}

func (v PackString) PackIntoUnsorted(p *PutAccess) {
	p.AddString(string(v))
}

type PackBytes []byte

func (v PackBytes) PackInto(p *PutAccess) {
	p.AddBytes([]byte(v))
}

func (v PackBytes) PackIntoUnsorted(p *PutAccess) {
	p.AddBytes([]byte(v))
}

type PackMapStr map[string]string

func (v PackMapStr) PackInto(p *PutAccess) {
	p.AddMapStr(map[string]string(v))
}

type PackMapBytes map[string][]byte

func (v PackMapBytes) PackInto(p *PutAccess) {
	p.AddMap(map[string][]byte(v))
}

type PackMapPackable map[string]Packable
type PackSortedMapPackable map[string]Packable

func (v PackMapPackable) PackInto(p *PutAccess) {
	m := (map[string]Packable)(v)
	p.offsets = binary.LittleEndian.AppendUint16(p.offsets, types.EncodeHeader(p.position, types.TypeMap))
	if len(m) > 0 {
		nested := NewPutAccessFromPool()
		for k, val := range m {
			nested.AddString(k)
			val.PackInto(nested)
		}
		p.appendAndReleaseNested(nested)
	}

}

func (v PackSortedMapPackable) PackInto(p *PutAccess) {
	keys := make([]string, 0, len(v))
	for k := range v {
		keys = append(keys, k)
	}
	sort.Strings(keys)

	p.offsets = binary.LittleEndian.AppendUint16(p.offsets, types.EncodeHeader(p.position, types.TypeMap))
	if len(keys) > 0 {
		nested := NewPutAccessFromPool()
		for _, k := range keys {
			nested.AddString(k)
			v[k].PackInto(nested)
		}
		p.appendAndReleaseNested(nested)
	}
}

func PackArgs(args ...Packable) []byte {
	put := NewPutAccessFromPool()
	for _, arg := range args {
		arg.PackInto(put)
	}
	ret := put.Pack()
	ReleasePutAccess(put)
	return ret
}

func (v PackInt16) PayloadSize() int   { return 2 }
func (v PackInt32) PayloadSize() int   { return 4 }
func (v PackInt64) PayloadSize() int   { return 8 }
func (v PackFloat32) PayloadSize() int { return 4 }
func (v PackFloat64) PayloadSize() int { return 8 }
func (v PackBool) PayloadSize() int    { return 1 }
func (v PackString) PayloadSize() int  { return len(v) }
func (v PackBytes) PayloadSize() int   { return len(v) }

func (v PackNullableInt16) PayloadSize() int {
	if v.V == nil {
		return 0
	}
	return 2
}

func (v PackNullableInt32) PayloadSize() int {
	if v.V == nil {
		return 0
	}
	return 4
}

func (v PackNullableInt64) PayloadSize() int {
	if v.V == nil {
		return 0
	}
	return 8
}

func (v PackNullableFloat32) PayloadSize() int {
	if v.V == nil {
		return 0
	}
	return 4
}

func (v PackNullableFloat64) PayloadSize() int {
	if v.V == nil {
		return 0
	}
	return 8
}

func (v PackNullableBool) PayloadSize() int {
	if v.V == nil {
		return 0
	}
	return 1
}

func (v PackInt16) IsContainer() bool   { return false }
func (v PackInt32) IsContainer() bool   { return false }
func (v PackInt64) IsContainer() bool   { return false }
func (v PackFloat32) IsContainer() bool { return false }
func (v PackFloat64) IsContainer() bool { return false }
func (v PackBool) IsContainer() bool    { return false }

func (v PackNullableInt16) IsContainer() bool   { return false }
func (v PackNullableInt32) IsContainer() bool   { return false }
func (v PackNullableInt64) IsContainer() bool   { return false }
func (v PackNullableFloat32) IsContainer() bool { return false }
func (v PackNullableFloat64) IsContainer() bool { return false }
func (v PackNullableBool) IsContainer() bool    { return false }

func (v PackString) IsContainer() bool { return false }
func (v PackBytes) IsContainer() bool  { return false }

func (v PackMapStr) IsContainer() bool                                         { return true }
func (v PackMapBytes) IsContainer() bool                                       { return true }
func (v PackMapPackable) IsContainer() bool                                    { return true }
func (v PackSortedMapPackable) IsContainer() bool                              { return true }
func (v PackInt16) ComputeSizes(nestedHeaderSize []int16) (int, error)         { panic("error") }
func (v PackInt32) ComputeSizes(nestedHeaderSize []int16) (int, error)         { panic("error") }
func (v PackBool) ComputeSizes(nestedHeaderSize []int16) (int, error)          { panic("error") }
func (v PackFloat64) ComputeSizes(nestedHeaderSize []int16) (int, error)       { panic("error") }
func (v PackNullableInt32) ComputeSizes(nestedHeaderSize []int16) (int, error) { panic("error") }
func (v PackNullableBool) ComputeSizes(nestedHeaderSize []int16) (int, error)  { panic("error") }
func (v PackString) ComputeSizes(nestedHeaderSize []int16) (int, error)        { panic("error") }
func (v PackBytes) ComputeSizes(nestedHeaderSize []int16) (int, error)         { panic("error") }
func (v PackInt16) PackIntoAfterComputeSize(p *PutAccess, buffer []byte, nestedHeaderSize []int16) error {
	panic("PackInt16 cannot use PackIntoAfterComputeSize")
}

func (v PackInt32) PackIntoAfterComputeSize(p *PutAccess, buffer []byte, nestedHeaderSize []int16) error {
	panic("PackInt32 cannot use PackIntoAfterComputeSize")
}

func (v PackBool) PackIntoAfterComputeSize(p *PutAccess, buffer []byte, nestedHeaderSize []int16) error {
	panic("PackBool cannot use PackIntoAfterComputeSize")
}

func (v PackFloat64) PackIntoAfterComputeSize(p *PutAccess, buffer []byte, nestedHeaderSize []int16) error {
	panic("PackFloat64 cannot use PackIntoAfterComputeSize")
}

func (v PackNullableInt32) PackIntoAfterComputeSize(p *PutAccess, buffer []byte, nestedHeaderSize []int16) error {
	panic("PackNullableInt32 cannot use PackIntoAfterComputeSize")
}

func (v PackNullableBool) PackIntoAfterComputeSize(p *PutAccess, buffer []byte, nestedHeaderSize []int16) error {
	panic("PackNullableBool cannot use PackIntoAfterComputeSize")
}

func (v PackString) PackIntoAfterComputeSize(p *PutAccess, buffer []byte, nestedHeaderSize []int16) error {
	panic("PackString cannot use PackIntoAfterComputeSize")
}

func (v PackBytes) PackIntoAfterComputeSize(p *PutAccess, buffer []byte, nestedHeaderSize []int16) error {
	panic("PackBytes cannot use PackIntoAfterComputeSize")
}

func (v PackMapPackable) PayloadSize() int {
	panic("should not be called")
}
func (v PackSortedMapPackable) PayloadSize() int {
	panic("should not be called")
}
func (v PackMapStr) PayloadSize() int {
	panic("should not be called")
}
func (v PackMapBytes) PayloadSize() int {
	panic("should not be called")
}

func ComputeSizesMapPayload(nestedHeaderSize []int16, m map[string]Packable) (int, error) {
	if len(nestedHeaderSize) < 2 {
		return 0, errors.New("not sufficient")
	}
	// account inner_args..|inner_end_tag|
	// len(m) is keys size we should double it
	// uint16 is 2 bytes we should double again
	headerSize := 4*len(m) + 2
	payloadSize := 0

	for k, val := range m {
		payloadSize += len(k)
		if val.IsContainer() {
			pSize, err := val.ComputeSizes(nestedHeaderSize[1:])
			if err != nil {
				return 0, err
			}
			payloadSize += int(pSize)
		} else {
			payloadSize += val.PayloadSize()
		}
	}

	nestedHeaderSize[0] = int16(headerSize)

	return headerSize + payloadSize, nil
}
func (v PackSortedMapPackable) ComputeSizes(nestedHeaderSize []int16) (int, error) {
	return ComputeSizesMapPayload(nestedHeaderSize, (map[string]Packable)(v))
}
func (v PackMapPackable) ComputeSizes(nestedHeaderSize []int16) (int, error) {
	return ComputeSizesMapPayload(nestedHeaderSize, (map[string]Packable)(v))
}

func (v PackMapStr) ComputeSizes(nestedHeaderSize []int16) (int, error) {
	if len(nestedHeaderSize) < 2 {
		return 0, errors.New("not sufficient")
	}
	m := (map[string]string)(v)
	headerSize := 4*len(m) + 2
	payloadSize := 0

	for k, val := range m {
		payloadSize += len(k)
		payloadSize += len(val)
	}
	nestedHeaderSize[0] = int16(headerSize)
	return headerSize + payloadSize, nil
}

func (v PackMapBytes) ComputeSizes(nestedHeaderSize []int16) (int, error) {
	if len(nestedHeaderSize) < 2 {
		return 0, errors.New("not sufficient")
	}
	m := (map[string][]byte)(v)
	headerSize := 4*len(m) + 2
	payloadSize := 0

	for k, val := range m {
		payloadSize += len(k)
		payloadSize += len(val)
	}
	nestedHeaderSize[0] = int16(headerSize)
	return headerSize + payloadSize, nil
}

func ComputeSizes(nestedHeaderSize []int16, args ...Packable) (int, error) {
	if len(nestedHeaderSize) < 2 {
		return 0, errors.New("not sufficient")
	}
	payloadSize := 0
	for _, arg := range args {
		if arg.IsContainer() {
			pSize, err := arg.ComputeSizes(nestedHeaderSize[1:])
			if err != nil {
				return 0, err
			}
			payloadSize += int(pSize)
		} else {
			payloadSize += arg.PayloadSize()
		}
	}
	nestedHeaderSize[0] = int16(2 + len(args)*2)
	return payloadSize, nil
}

var bPool *utils.BufferPool = utils.NewBufferPool()

func (v PackMapStr) PackIntoAfterComputeSize(p *PutAccess, buffer []byte, nestedHeaderSize []int16) error {
	if len(nestedHeaderSize) < 2 {
		return errors.New("not sufficient")
	}
	m := (map[string]string)(v)
	p.offsets = binary.LittleEndian.AppendUint16(p.offsets, types.EncodeHeader(p.position, types.TypeMap))
	if len(m) > 0 {
		headSize := int(nestedHeaderSize[0])
		headOffset := p.position + headSize

		nested := PutAccess{
			buf:     buffer[headOffset:headOffset],
			offsets: buffer[p.position:p.position],
		}
		for k := range m {
			nested.AddString(k)
			nested.AddString(m[k])
		}
		FinalizeHeader(&nested)
		//simulate append growth
		fix_pos := nested.position + len(nested.offsets)
		//fix buffer len
		p.position += fix_pos
		p.buf = buffer[0:p.position]
	}

	return nil
}

func (v PackMapBytes) PackIntoAfterComputeSize(p *PutAccess, buffer []byte, nestedHeaderSize []int16) error {
	if len(nestedHeaderSize) < 2 {
		return errors.New("not sufficient")
	}
	m := (map[string][]byte)(v)
	p.offsets = binary.LittleEndian.AppendUint16(p.offsets, types.EncodeHeader(p.position, types.TypeMap))
	if len(m) > 0 {
		headSize := int(nestedHeaderSize[0])
		headOffset := p.position + headSize

		nested := PutAccess{
			buf:     buffer[headOffset:headOffset],
			offsets: buffer[p.position:p.position],
		}
		for k := range m {
			nested.AddString(k)
			nested.AddBytes(m[k])
		}
		FinalizeHeader(&nested)
		//simulate append growth
		fix_pos := nested.position + len(nested.offsets)
		//fix buffer len
		p.position += fix_pos
		p.buf = buffer[0:p.position]
	}

	return nil
}

func (v PackMapPackable) PackIntoAfterComputeSize(p *PutAccess, buffer []byte, nestedHeaderSize []int16) error {
	if len(nestedHeaderSize) < 2 {
		return errors.New("not sufficient")
	}
	m := (map[string]Packable)(v)
	p.offsets = binary.LittleEndian.AppendUint16(p.offsets, types.EncodeHeader(p.position, types.TypeMap))
	if len(m) > 0 {
		headSize := int(nestedHeaderSize[0])
		headOffset := p.position + headSize

		nested := PutAccess{
			buf:     buffer[headOffset:headOffset],
			offsets: buffer[p.position:p.position],
		}
		for k := range m {
			nested.AddString(k)

			if v[k].IsContainer() {
				err := v[k].PackIntoAfterComputeSize(&nested, buffer[headOffset:], nestedHeaderSize[1:])
				if err != nil {
					return err
				}
			} else {
				v[k].PackInto(&nested)
			}

		}
		FinalizeHeader(&nested)
		//simulate append growth
		fix_pos := nested.position + len(nested.offsets)
		//fix buffer len
		p.position += fix_pos
		p.buf = buffer[0:p.position]
	}

	return nil
}

func (v PackSortedMapPackable) PackIntoAfterComputeSize(p *PutAccess, buffer []byte, nestedHeaderSize []int16) error {
	if len(nestedHeaderSize) < 2 {
		return errors.New("not sufficient")
	}
	keys := make([]string, 0, len(v))
	for k := range v {
		keys = append(keys, k)
	}
	sort.Strings(keys)

	p.offsets = binary.LittleEndian.AppendUint16(p.offsets, types.EncodeHeader(p.position, types.TypeMap))
	if len(keys) > 0 {
		headSize := int(nestedHeaderSize[0])
		headOffset := p.position + headSize

		nested := &PutAccess{
			buf:     buffer[headOffset:headOffset],
			offsets: buffer[p.position:p.position],
		}
		for _, k := range keys {
			nested.AddString(k)

			if v[k].IsContainer() {
				err := v[k].PackIntoAfterComputeSize(nested, buffer[headOffset:], nestedHeaderSize[1:])
				if err != nil {
					return err
				}
			} else {
				v[k].PackInto(nested)
			}

		}
		FinalizeHeader(nested)
		//simulate append growth
		fix_pos := nested.position + len(nested.offsets)
		//fix buffer len
		p.position += fix_pos
		p.buf = buffer[0:p.position]

	}

	return nil
}

func FinalizeHeader(put *PutAccess) {
	put.offsets = binary.LittleEndian.AppendUint16(put.offsets, types.EncodeEnd(put.position))

	headerSize := len(put.offsets)
	payloadBase := headerSize

	hdr := types.EncodeHeader(payloadBase, types.Type(put.offsets[0]&0x07))
	put.offsets[0] = byte(hdr)
}

func PackArgsAfterComputeSizes(usePoolForReturn bool, args ...Packable) ([]byte, error) {
	sizeList := bPool.AcquireInt16(512)
	defer bPool.ReleaseInt16(sizeList)
	payloadSize, err := ComputeSizes(sizeList, args...)
	if err != nil {
		return nil, fmt.Errorf("error %w", err)
	}
	headOffset := int(sizeList[0])
	total := headOffset + payloadSize
	var buffer []byte
	if usePoolForReturn {
		buffer = bPool.Acquire(total)
	} else {
		buffer = make([]byte, total)
	}

	put := PutAccess{
		buf:     buffer[headOffset:headOffset],
		offsets: buffer[:0],
	}
	for _, arg := range args {
		if arg.IsContainer() {
			err := arg.PackIntoAfterComputeSize(&put, buffer[headOffset:], sizeList[1:])
			if err != nil {
				return nil, err
			}
		} else {
			arg.PackInto(&put)
		}

	}
	FinalizeHeader(&put)

	return buffer, nil
}
